// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/Team-bluekunVRC/discord-bot/ent/audioclip"
	"github.com/Team-bluekunVRC/discord-bot/ent/discorduser"
	"github.com/Team-bluekunVRC/discord-bot/ent/image"
	"github.com/Team-bluekunVRC/discord-bot/ent/predicate"
	"github.com/Team-bluekunVRC/discord-bot/ent/role"
	"github.com/Team-bluekunVRC/discord-bot/ent/user"
	"github.com/Team-bluekunVRC/discord-bot/ent/vrcuser"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAudioClip   = "AudioClip"
	TypeDiscordUser = "DiscordUser"
	TypeImage       = "Image"
	TypeRole        = "Role"
	TypeUser        = "User"
	TypeVRCUser     = "VRCUser"
)

// AudioClipMutation represents an operation that mutates the AudioClip nodes in the graph.
type AudioClipMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	storage_path  *string
	_type         *audioclip.Type
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AudioClip, error)
	predicates    []predicate.AudioClip
}

var _ ent.Mutation = (*AudioClipMutation)(nil)

// audioclipOption allows management of the mutation configuration using functional options.
type audioclipOption func(*AudioClipMutation)

// newAudioClipMutation creates new mutation for the AudioClip entity.
func newAudioClipMutation(c config, op Op, opts ...audioclipOption) *AudioClipMutation {
	m := &AudioClipMutation{
		config:        c,
		op:            op,
		typ:           TypeAudioClip,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAudioClipID sets the ID field of the mutation.
func withAudioClipID(id uuid.UUID) audioclipOption {
	return func(m *AudioClipMutation) {
		var (
			err   error
			once  sync.Once
			value *AudioClip
		)
		m.oldValue = func(ctx context.Context) (*AudioClip, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AudioClip.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAudioClip sets the old AudioClip of the mutation.
func withAudioClip(node *AudioClip) audioclipOption {
	return func(m *AudioClipMutation) {
		m.oldValue = func(context.Context) (*AudioClip, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AudioClipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AudioClipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AudioClip entities.
func (m *AudioClipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AudioClipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStoragePath sets the "storage_path" field.
func (m *AudioClipMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *AudioClipMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the AudioClip entity.
// If the AudioClip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AudioClipMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *AudioClipMutation) ResetStoragePath() {
	m.storage_path = nil
}

// SetType sets the "type" field.
func (m *AudioClipMutation) SetType(a audioclip.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AudioClipMutation) GetType() (r audioclip.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AudioClip entity.
// If the AudioClip object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AudioClipMutation) OldType(ctx context.Context) (v audioclip.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AudioClipMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the AudioClipMutation builder.
func (m *AudioClipMutation) Where(ps ...predicate.AudioClip) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AudioClipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AudioClip).
func (m *AudioClipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AudioClipMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.storage_path != nil {
		fields = append(fields, audioclip.FieldStoragePath)
	}
	if m._type != nil {
		fields = append(fields, audioclip.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AudioClipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case audioclip.FieldStoragePath:
		return m.StoragePath()
	case audioclip.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AudioClipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case audioclip.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case audioclip.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown AudioClip field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AudioClipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case audioclip.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case audioclip.FieldType:
		v, ok := value.(audioclip.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown AudioClip field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AudioClipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AudioClipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AudioClipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AudioClip numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AudioClipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AudioClipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AudioClipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AudioClip nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AudioClipMutation) ResetField(name string) error {
	switch name {
	case audioclip.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case audioclip.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown AudioClip field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AudioClipMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AudioClipMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AudioClipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AudioClipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AudioClipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AudioClipMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AudioClipMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AudioClip unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AudioClipMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AudioClip edge %s", name)
}

// DiscordUserMutation represents an operation that mutates the DiscordUser nodes in the graph.
type DiscordUserMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	user          map[uuid.UUID]struct{}
	removeduser   map[uuid.UUID]struct{}
	cleareduser   bool
	vrc           map[string]struct{}
	removedvrc    map[string]struct{}
	clearedvrc    bool
	done          bool
	oldValue      func(context.Context) (*DiscordUser, error)
	predicates    []predicate.DiscordUser
}

var _ ent.Mutation = (*DiscordUserMutation)(nil)

// discorduserOption allows management of the mutation configuration using functional options.
type discorduserOption func(*DiscordUserMutation)

// newDiscordUserMutation creates new mutation for the DiscordUser entity.
func newDiscordUserMutation(c config, op Op, opts ...discorduserOption) *DiscordUserMutation {
	m := &DiscordUserMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscordUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscordUserID sets the ID field of the mutation.
func withDiscordUserID(id string) discorduserOption {
	return func(m *DiscordUserMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscordUser
		)
		m.oldValue = func(ctx context.Context) (*DiscordUser, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscordUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscordUser sets the old DiscordUser of the mutation.
func withDiscordUser(node *DiscordUser) discorduserOption {
	return func(m *DiscordUserMutation) {
		m.oldValue = func(context.Context) (*DiscordUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscordUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscordUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DiscordUser entities.
func (m *DiscordUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscordUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *DiscordUserMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.user == nil {
		m.user = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *DiscordUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DiscordUserMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *DiscordUserMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removeduser == nil {
		m.removeduser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *DiscordUserMutation) RemovedUserIDs() (ids []uuid.UUID) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *DiscordUserMutation) UserIDs() (ids []uuid.UUID) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DiscordUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddVrcIDs adds the "vrc" edge to the VRCUser entity by ids.
func (m *DiscordUserMutation) AddVrcIDs(ids ...string) {
	if m.vrc == nil {
		m.vrc = make(map[string]struct{})
	}
	for i := range ids {
		m.vrc[ids[i]] = struct{}{}
	}
}

// ClearVrc clears the "vrc" edge to the VRCUser entity.
func (m *DiscordUserMutation) ClearVrc() {
	m.clearedvrc = true
}

// VrcCleared reports if the "vrc" edge to the VRCUser entity was cleared.
func (m *DiscordUserMutation) VrcCleared() bool {
	return m.clearedvrc
}

// RemoveVrcIDs removes the "vrc" edge to the VRCUser entity by IDs.
func (m *DiscordUserMutation) RemoveVrcIDs(ids ...string) {
	if m.removedvrc == nil {
		m.removedvrc = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vrc, ids[i])
		m.removedvrc[ids[i]] = struct{}{}
	}
}

// RemovedVrc returns the removed IDs of the "vrc" edge to the VRCUser entity.
func (m *DiscordUserMutation) RemovedVrcIDs() (ids []string) {
	for id := range m.removedvrc {
		ids = append(ids, id)
	}
	return
}

// VrcIDs returns the "vrc" edge IDs in the mutation.
func (m *DiscordUserMutation) VrcIDs() (ids []string) {
	for id := range m.vrc {
		ids = append(ids, id)
	}
	return
}

// ResetVrc resets all changes to the "vrc" edge.
func (m *DiscordUserMutation) ResetVrc() {
	m.vrc = nil
	m.clearedvrc = false
	m.removedvrc = nil
}

// Where appends a list predicates to the DiscordUserMutation builder.
func (m *DiscordUserMutation) Where(ps ...predicate.DiscordUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DiscordUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DiscordUser).
func (m *DiscordUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscordUserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscordUserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscordUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown DiscordUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscordUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscordUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscordUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordUserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown DiscordUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscordUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscordUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscordUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DiscordUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscordUserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown DiscordUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscordUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, discorduser.EdgeUser)
	}
	if m.vrc != nil {
		edges = append(edges, discorduser.EdgeVrc)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscordUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discorduser.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case discorduser.EdgeVrc:
		ids := make([]ent.Value, 0, len(m.vrc))
		for id := range m.vrc {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscordUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, discorduser.EdgeUser)
	}
	if m.removedvrc != nil {
		edges = append(edges, discorduser.EdgeVrc)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscordUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case discorduser.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case discorduser.EdgeVrc:
		ids := make([]ent.Value, 0, len(m.removedvrc))
		for id := range m.removedvrc {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscordUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, discorduser.EdgeUser)
	}
	if m.clearedvrc {
		edges = append(edges, discorduser.EdgeVrc)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscordUserMutation) EdgeCleared(name string) bool {
	switch name {
	case discorduser.EdgeUser:
		return m.cleareduser
	case discorduser.EdgeVrc:
		return m.clearedvrc
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscordUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscordUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscordUserMutation) ResetEdge(name string) error {
	switch name {
	case discorduser.EdgeUser:
		m.ResetUser()
		return nil
	case discorduser.EdgeVrc:
		m.ResetVrc()
		return nil
	}
	return fmt.Errorf("unknown DiscordUser edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	storage_path  *string
	_type         *image.Type
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id uuid.UUID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStoragePath sets the "storage_path" field.
func (m *ImageMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *ImageMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *ImageMutation) ResetStoragePath() {
	m.storage_path = nil
}

// SetType sets the "type" field.
func (m *ImageMutation) SetType(i image.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImageMutation) GetType() (r image.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldType(ctx context.Context) (v image.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImageMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.storage_path != nil {
		fields = append(fields, image.FieldStoragePath)
	}
	if m._type != nil {
		fields = append(fields, image.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldStoragePath:
		return m.StoragePath()
	case image.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case image.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case image.FieldType:
		v, ok := value.(image.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case image.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Image edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Role edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	email         *string
	clearedFields map[string]struct{}
	images        map[uuid.UUID]struct{}
	removedimages map[uuid.UUID]struct{}
	clearedimages bool
	audio         map[uuid.UUID]struct{}
	removedaudio  map[uuid.UUID]struct{}
	clearedaudio  bool
	role          map[uuid.UUID]struct{}
	removedrole   map[uuid.UUID]struct{}
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddImageIDs adds the "images" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Image entity.
func (m *UserMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Image entity was cleared.
func (m *UserMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Image entity.
func (m *UserMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *UserMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *UserMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddAudioIDs adds the "audio" edge to the AudioClip entity by ids.
func (m *UserMutation) AddAudioIDs(ids ...uuid.UUID) {
	if m.audio == nil {
		m.audio = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.audio[ids[i]] = struct{}{}
	}
}

// ClearAudio clears the "audio" edge to the AudioClip entity.
func (m *UserMutation) ClearAudio() {
	m.clearedaudio = true
}

// AudioCleared reports if the "audio" edge to the AudioClip entity was cleared.
func (m *UserMutation) AudioCleared() bool {
	return m.clearedaudio
}

// RemoveAudioIDs removes the "audio" edge to the AudioClip entity by IDs.
func (m *UserMutation) RemoveAudioIDs(ids ...uuid.UUID) {
	if m.removedaudio == nil {
		m.removedaudio = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.audio, ids[i])
		m.removedaudio[ids[i]] = struct{}{}
	}
}

// RemovedAudio returns the removed IDs of the "audio" edge to the AudioClip entity.
func (m *UserMutation) RemovedAudioIDs() (ids []uuid.UUID) {
	for id := range m.removedaudio {
		ids = append(ids, id)
	}
	return
}

// AudioIDs returns the "audio" edge IDs in the mutation.
func (m *UserMutation) AudioIDs() (ids []uuid.UUID) {
	for id := range m.audio {
		ids = append(ids, id)
	}
	return
}

// ResetAudio resets all changes to the "audio" edge.
func (m *UserMutation) ResetAudio() {
	m.audio = nil
	m.clearedaudio = false
	m.removedaudio = nil
}

// AddRoleIDs adds the "role" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.role == nil {
		m.role = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.role[ids[i]] = struct{}{}
	}
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RemoveRoleIDs removes the "role" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedrole == nil {
		m.removedrole = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.role, ids[i])
		m.removedrole[ids[i]] = struct{}{}
	}
}

// RemovedRole returns the removed IDs of the "role" edge to the Role entity.
func (m *UserMutation) RemovedRoleIDs() (ids []uuid.UUID) {
	for id := range m.removedrole {
		ids = append(ids, id)
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
func (m *UserMutation) RoleIDs() (ids []uuid.UUID) {
	for id := range m.role {
		ids = append(ids, id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
	m.removedrole = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.images != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.audio != nil {
		edges = append(edges, user.EdgeAudio)
	}
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAudio:
		ids := make([]ent.Value, 0, len(m.audio))
		for id := range m.audio {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRole:
		ids := make([]ent.Value, 0, len(m.role))
		for id := range m.role {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedimages != nil {
		edges = append(edges, user.EdgeImages)
	}
	if m.removedaudio != nil {
		edges = append(edges, user.EdgeAudio)
	}
	if m.removedrole != nil {
		edges = append(edges, user.EdgeRole)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAudio:
		ids := make([]ent.Value, 0, len(m.removedaudio))
		for id := range m.removedaudio {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRole:
		ids := make([]ent.Value, 0, len(m.removedrole))
		for id := range m.removedrole {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedimages {
		edges = append(edges, user.EdgeImages)
	}
	if m.clearedaudio {
		edges = append(edges, user.EdgeAudio)
	}
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeImages:
		return m.clearedimages
	case user.EdgeAudio:
		return m.clearedaudio
	case user.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeImages:
		m.ResetImages()
		return nil
	case user.EdgeAudio:
		m.ResetAudio()
		return nil
	case user.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VRCUserMutation represents an operation that mutates the VRCUser nodes in the graph.
type VRCUserMutation struct {
	config
	op             Op
	typ            string
	id             *string
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	discord        *string
	cleareddiscord bool
	done           bool
	oldValue       func(context.Context) (*VRCUser, error)
	predicates     []predicate.VRCUser
}

var _ ent.Mutation = (*VRCUserMutation)(nil)

// vrcuserOption allows management of the mutation configuration using functional options.
type vrcuserOption func(*VRCUserMutation)

// newVRCUserMutation creates new mutation for the VRCUser entity.
func newVRCUserMutation(c config, op Op, opts ...vrcuserOption) *VRCUserMutation {
	m := &VRCUserMutation{
		config:        c,
		op:            op,
		typ:           TypeVRCUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVRCUserID sets the ID field of the mutation.
func withVRCUserID(id string) vrcuserOption {
	return func(m *VRCUserMutation) {
		var (
			err   error
			once  sync.Once
			value *VRCUser
		)
		m.oldValue = func(ctx context.Context) (*VRCUser, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VRCUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVRCUser sets the old VRCUser of the mutation.
func withVRCUser(node *VRCUser) vrcuserOption {
	return func(m *VRCUserMutation) {
		m.oldValue = func(context.Context) (*VRCUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VRCUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VRCUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VRCUser entities.
func (m *VRCUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VRCUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VRCUserMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VRCUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VRCUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VRCUserMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VRCUserMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VRCUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDiscordID sets the "discord" edge to the DiscordUser entity by id.
func (m *VRCUserMutation) SetDiscordID(id string) {
	m.discord = &id
}

// ClearDiscord clears the "discord" edge to the DiscordUser entity.
func (m *VRCUserMutation) ClearDiscord() {
	m.cleareddiscord = true
}

// DiscordCleared reports if the "discord" edge to the DiscordUser entity was cleared.
func (m *VRCUserMutation) DiscordCleared() bool {
	return m.cleareddiscord
}

// DiscordID returns the "discord" edge ID in the mutation.
func (m *VRCUserMutation) DiscordID() (id string, exists bool) {
	if m.discord != nil {
		return *m.discord, true
	}
	return
}

// DiscordIDs returns the "discord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscordID instead. It exists only for internal usage by the builders.
func (m *VRCUserMutation) DiscordIDs() (ids []string) {
	if id := m.discord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscord resets all changes to the "discord" edge.
func (m *VRCUserMutation) ResetDiscord() {
	m.discord = nil
	m.cleareddiscord = false
}

// Where appends a list predicates to the VRCUserMutation builder.
func (m *VRCUserMutation) Where(ps ...predicate.VRCUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VRCUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VRCUser).
func (m *VRCUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VRCUserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VRCUserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VRCUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown VRCUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VRCUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VRCUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VRCUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VRCUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VRCUserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown VRCUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VRCUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VRCUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VRCUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VRCUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VRCUserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown VRCUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VRCUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, vrcuser.EdgeUser)
	}
	if m.discord != nil {
		edges = append(edges, vrcuser.EdgeDiscord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VRCUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vrcuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case vrcuser.EdgeDiscord:
		if id := m.discord; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VRCUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VRCUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VRCUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, vrcuser.EdgeUser)
	}
	if m.cleareddiscord {
		edges = append(edges, vrcuser.EdgeDiscord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VRCUserMutation) EdgeCleared(name string) bool {
	switch name {
	case vrcuser.EdgeUser:
		return m.cleareduser
	case vrcuser.EdgeDiscord:
		return m.cleareddiscord
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VRCUserMutation) ClearEdge(name string) error {
	switch name {
	case vrcuser.EdgeUser:
		m.ClearUser()
		return nil
	case vrcuser.EdgeDiscord:
		m.ClearDiscord()
		return nil
	}
	return fmt.Errorf("unknown VRCUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VRCUserMutation) ResetEdge(name string) error {
	switch name {
	case vrcuser.EdgeUser:
		m.ResetUser()
		return nil
	case vrcuser.EdgeDiscord:
		m.ResetDiscord()
		return nil
	}
	return fmt.Errorf("unknown VRCUser edge %s", name)
}
